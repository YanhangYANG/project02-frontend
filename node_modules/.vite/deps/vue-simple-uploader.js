import {
  Fragment,
  computed,
  createBlock,
  createTextVNode,
  createVNode,
  getCurrentInstance,
  inject,
  nextTick,
  onBeforeUnmount,
  onMounted,
  onUnmounted,
  openBlock,
  provide,
  ref,
  renderList,
  renderSlot,
  resolveComponent,
  toDisplayString,
  toRaw,
  vShow,
  watch,
  withCtx,
  withDirectives
} from "./chunk-J6475X5X.js";
import "./chunk-UXIASGQL.js";

// node_modules/vue-simple-uploader/dist/vue-simple-uploader.es.js
function R(e2) {
  throw new Error('Could not dynamically require "' + e2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var F = { exports: {} };
var E = F.exports = function e(t, i, s) {
  function r(o2, a) {
    if (!i[o2]) {
      if (!t[o2]) {
        if (!a && R)
          return R(o2);
        if (n)
          return n(o2, true);
        throw new Error("Cannot find module '" + o2 + "'");
      }
      var l = i[o2] = { exports: {} };
      t[o2][0].call(l.exports, function(e2) {
        var i2 = t[o2][1][e2];
        return r(i2 || e2);
      }, l, l.exports, e, t, i, s);
    }
    return i[o2].exports;
  }
  for (var n = R, o = 0; o < s.length; o++)
    r(s[o]);
  return r;
}({ 1: [function(e2, t, i) {
  var s = e2("./utils");
  function r(e3, t2, i2) {
    s.defineNonEnumerable(this, "uploader", e3), s.defineNonEnumerable(this, "file", t2), s.defineNonEnumerable(this, "bytes", null), this.offset = i2, this.tested = false, this.retries = 0, this.pendingRetry = false, this.preprocessState = 0, this.readState = 0, this.loaded = 0, this.total = 0, this.chunkSize = s.evalOpts(e3.opts.chunkSize, t2, this), this.startByte = this.offset * this.chunkSize, this.endByte = this.computeEndByte(), this.xhr = null;
  }
  var n = r.STATUS = { PENDING: "pending", UPLOADING: "uploading", READING: "reading", SUCCESS: "success", ERROR: "error", COMPLETE: "complete", PROGRESS: "progress", RETRY: "retry" };
  s.extend(r.prototype, { _event: function(e3, t2) {
    (t2 = s.toArray(arguments)).unshift(this), this.file._chunkEvent.apply(this.file, t2);
  }, computeEndByte: function() {
    var e3 = Math.min(this.file.size, (this.offset + 1) * this.chunkSize);
    return this.file.size - e3 < this.chunkSize && !this.uploader.opts.forceChunkSize && (e3 = this.file.size), e3;
  }, getParams: function() {
    return { chunkNumber: this.offset + 1, chunkSize: this.chunkSize, currentChunkSize: this.endByte - this.startByte, totalSize: this.file.size, identifier: this.file.uniqueIdentifier, filename: this.file.name, relativePath: this.file.relativePath, totalChunks: this.file.chunks.length };
  }, getTarget: function(e3, t2) {
    return t2.length ? (e3.indexOf("?") < 0 ? e3 += "?" : e3 += "&", e3 + t2.join("&")) : e3;
  }, test: function() {
    this.xhr = new XMLHttpRequest(), this.xhr.addEventListener("load", r2, false), this.xhr.addEventListener("error", r2, false);
    var e3 = s.evalOpts(this.uploader.opts.testMethod, this.file, this), t2 = this.prepareXhrRequest(e3, true);
    this.xhr.send(t2);
    var i2 = this;
    function r2(e4) {
      var t3 = i2.status(true);
      t3 === n.ERROR ? (i2._event(t3, i2.message()), i2.uploader.uploadNextChunk()) : t3 === n.SUCCESS ? (i2._event(t3, i2.message()), i2.tested = true) : i2.file.paused || (i2.tested = true, i2.send());
    }
  }, preprocessFinished: function() {
    this.endByte = this.computeEndByte(), this.preprocessState = 2, this.send();
  }, readFinished: function(e3) {
    this.readState = 2, this.bytes = e3, this.send();
  }, send: function() {
    var e3 = this.uploader.opts.preprocess, t2 = this.uploader.opts.readFileFn;
    if (s.isFunction(e3))
      switch (this.preprocessState) {
        case 0:
          return this.preprocessState = 1, void e3(this);
        case 1:
          return;
      }
    switch (this.readState) {
      case 0:
        return this.readState = 1, void t2(this.file, this.file.fileType, this.startByte, this.endByte, this);
      case 1:
        return;
    }
    if (!this.uploader.opts.testChunks || this.tested) {
      this.loaded = 0, this.total = 0, this.pendingRetry = false, this.xhr = new XMLHttpRequest(), this.xhr.upload.addEventListener("progress", a, false), this.xhr.addEventListener("load", l, false), this.xhr.addEventListener("error", l, false);
      var i2 = s.evalOpts(this.uploader.opts.uploadMethod, this.file, this), r2 = this.prepareXhrRequest(i2, false, this.uploader.opts.method, this.bytes);
      this.xhr.send(r2);
      var o = this;
    } else
      this.test();
    function a(e4) {
      e4.lengthComputable && (o.loaded = e4.loaded, o.total = e4.total), o._event(n.PROGRESS, e4);
    }
    function l(e4) {
      var t3 = o.message();
      o.processingResponse = true, o.uploader.opts.processResponse(t3, function(e5, t4) {
        if (o.processingResponse = false, o.xhr) {
          o.processedState = { err: e5, res: t4 };
          var i3 = o.status();
          if (i3 === n.SUCCESS || i3 === n.ERROR)
            o._event(i3, t4), i3 === n.ERROR && o.uploader.uploadNextChunk();
          else {
            o._event(n.RETRY, t4), o.pendingRetry = true, o.abort(), o.retries++;
            var s2 = o.uploader.opts.chunkRetryInterval;
            null !== s2 ? setTimeout(function() {
              o.send();
            }, s2) : o.send();
          }
        }
      }, o.file, o);
    }
  }, abort: function() {
    var e3 = this.xhr;
    this.xhr = null, this.processingResponse = false, this.processedState = null, e3 && e3.abort();
  }, status: function(e3) {
    if (1 === this.readState)
      return n.READING;
    if (this.pendingRetry || 1 === this.preprocessState)
      return n.UPLOADING;
    if (this.xhr) {
      if (this.xhr.readyState < 4 || this.processingResponse)
        return n.UPLOADING;
      var t2;
      this.uploader.opts.successStatuses.indexOf(this.xhr.status) > -1 ? t2 = n.SUCCESS : this.uploader.opts.permanentErrors.indexOf(this.xhr.status) > -1 || !e3 && this.retries >= this.uploader.opts.maxChunkRetries ? t2 = n.ERROR : (this.abort(), t2 = n.PENDING);
      var i2 = this.processedState;
      return i2 && i2.err && (t2 = n.ERROR), t2;
    }
    return n.PENDING;
  }, message: function() {
    return this.xhr ? this.xhr.responseText : "";
  }, progress: function() {
    if (this.pendingRetry)
      return 0;
    var e3 = this.status();
    return e3 === n.SUCCESS || e3 === n.ERROR ? 1 : e3 === n.PENDING ? 0 : this.total > 0 ? this.loaded / this.total : 0;
  }, sizeUploaded: function() {
    var e3 = this.endByte - this.startByte;
    return this.status() !== n.SUCCESS && (e3 = this.progress() * e3), e3;
  }, prepareXhrRequest: function(e3, t2, i2, r2) {
    var n2 = s.evalOpts(this.uploader.opts.query, this.file, this, t2);
    n2 = s.extend(this.getParams(), n2), n2 = this.uploader.opts.processParams(n2, this.file, this, t2);
    var o = s.evalOpts(this.uploader.opts.target, this.file, this, t2), a = null;
    if ("GET" === e3 || "octet" === i2) {
      var l = [];
      s.each(n2, function(e4, t3) {
        l.push([encodeURIComponent(t3), encodeURIComponent(e4)].join("="));
      }), o = this.getTarget(o, l), a = r2 || null;
    } else
      a = new FormData(), s.each(n2, function(e4, t3) {
        a.append(t3, e4);
      }), void 0 !== r2 && a.append(this.uploader.opts.fileParameterName, r2, this.file.name);
    return this.xhr.open(e3, o, true), this.xhr.withCredentials = this.uploader.opts.withCredentials, s.each(s.evalOpts(this.uploader.opts.headers, this.file, this, t2), function(e4, t3) {
      this.xhr.setRequestHeader(t3, e4);
    }, this), a;
  } }), t.exports = r;
}, { "./utils": 5 }], 2: [function(e2, t, i) {
  var s = e2("./utils").each, r = { _eventData: null, on: function(e3, t2) {
    this._eventData || (this._eventData = {}), this._eventData[e3] || (this._eventData[e3] = []);
    var i2 = false;
    s(this._eventData[e3], function(e4) {
      if (e4 === t2)
        return i2 = true, false;
    }), i2 || this._eventData[e3].push(t2);
  }, off: function(e3, t2) {
    this._eventData || (this._eventData = {}), this._eventData[e3] && this._eventData[e3].length && (t2 ? s(this._eventData[e3], function(i2, s2) {
      if (i2 === t2)
        return this._eventData[e3].splice(s2, 1), false;
    }, this) : this._eventData[e3] = []);
  }, trigger: function(e3) {
    if (this._eventData || (this._eventData = {}), !this._eventData[e3])
      return true;
    var t2 = this._eventData[e3].slice.call(arguments, 1), i2 = false;
    return s(this._eventData[e3], function(e4) {
      i2 = false === e4.apply(this, t2) || i2;
    }, this), !i2;
  } };
  t.exports = r;
}, { "./utils": 5 }], 3: [function(e2, t, i) {
  var s = e2("./utils"), r = e2("./event"), n = e2("./file"), o = e2("./chunk"), a = "0.6.0", l = "undefined" == typeof window, u = !l && window.navigator.msPointerEnabled, p = function() {
    if (l)
      return false;
    var e3 = "slice", t2 = s.isDefined(window.File) && s.isDefined(window.Blob) && s.isDefined(window.FileList), i2 = null;
    return t2 && (i2 = window.Blob.prototype, s.each(["slice", "webkitSlice", "mozSlice"], function(t3) {
      if (i2[t3])
        return e3 = t3, false;
    }), t2 = !!i2[e3]), t2 && (d.sliceName = e3), i2 = null, t2;
  }(), h = function() {
    if (l)
      return false;
    var e3 = window.document.createElement("input");
    e3.type = "file";
    var t2 = "webkitdirectory" in e3 || "directory" in e3;
    return e3 = null, t2;
  }();
  function d(e3) {
    this.support = p, this.support && (this.supportDirectory = h, s.defineNonEnumerable(this, "filePaths", {}), this.opts = s.extend({}, d.defaults, e3 || {}), this.preventEvent = s.bind(this._preventEvent, this), n.call(this, this));
  }
  var f = function(e3, t2, i2, s2, r2) {
    r2.readFinished(e3.file[d.sliceName](i2, s2, t2));
  };
  d.version = a, d.defaults = { chunkSize: 1048576, forceChunkSize: false, simultaneousUploads: 3, singleFile: false, fileParameterName: "file", progressCallbacksInterval: 500, speedSmoothingFactor: 0.1, query: {}, headers: {}, withCredentials: false, preprocess: null, method: "multipart", testMethod: "GET", uploadMethod: "POST", prioritizeFirstAndLastChunk: false, allowDuplicateUploads: false, target: "/", testChunks: true, generateUniqueIdentifier: null, maxChunkRetries: 0, chunkRetryInterval: null, permanentErrors: [404, 415, 500, 501], successStatuses: [200, 201, 202], onDropStopPropagation: false, initFileFn: null, readFileFn: f, checkChunkUploadedByResponse: null, initialPaused: false, processResponse: function(e3, t2) {
    t2(null, e3);
  }, processParams: function(e3) {
    return e3;
  } }, d.utils = s, d.event = r, d.File = n, d.Chunk = o, d.prototype = s.extend({}, n.prototype), s.extend(d.prototype, r), s.extend(d.prototype, { constructor: d, _trigger: function(e3) {
    var t2 = s.toArray(arguments), i2 = !this.trigger.apply(this, arguments);
    return "catchAll" !== e3 && (t2.unshift("catchAll"), i2 = !this.trigger.apply(this, t2) || i2), !i2;
  }, _triggerAsync: function() {
    var e3 = arguments;
    s.nextTick(function() {
      this._trigger.apply(this, e3);
    }, this);
  }, addFiles: function(e3, t2) {
    var i2 = [], r2 = this.fileList.length;
    s.each(e3, function(e4) {
      if ((!u || u && e4.size > 0) && (e4.size % 4096 != 0 || "." !== e4.name && "." !== e4.fileName)) {
        var s2 = this.generateUniqueIdentifier(e4);
        if (this.opts.allowDuplicateUploads || !this.getFromUniqueIdentifier(s2)) {
          var r3 = new n(this, e4, this);
          r3.uniqueIdentifier = s2, this._trigger("fileAdded", r3, t2) ? i2.push(r3) : n.prototype.removeFile.call(this, r3);
        }
      }
    }, this);
    var o2 = this.fileList.slice(r2);
    this._trigger("filesAdded", i2, o2, t2) ? (s.each(i2, function(e4) {
      this.opts.singleFile && this.files.length > 0 && this.removeFile(this.files[0]), this.files.push(e4);
    }, this), this._trigger("filesSubmitted", i2, o2, t2)) : s.each(o2, function(e4) {
      n.prototype.removeFile.call(this, e4);
    }, this);
  }, addFile: function(e3, t2) {
    this.addFiles([e3], t2);
  }, cancel: function() {
    for (var e3 = this.fileList.length - 1; e3 >= 0; e3--)
      this.fileList[e3].cancel();
  }, removeFile: function(e3) {
    n.prototype.removeFile.call(this, e3), this._trigger("fileRemoved", e3);
  }, generateUniqueIdentifier: function(e3) {
    var t2 = this.opts.generateUniqueIdentifier;
    if (s.isFunction(t2))
      return t2(e3);
    var i2 = e3.relativePath || e3.webkitRelativePath || e3.fileName || e3.name;
    return e3.size + "-" + i2.replace(/[^0-9a-zA-Z_-]/gim, "");
  }, getFromUniqueIdentifier: function(e3) {
    var t2 = false;
    return s.each(this.files, function(i2) {
      if (i2.uniqueIdentifier === e3)
        return t2 = i2, false;
    }), t2;
  }, uploadNextChunk: function(e3) {
    var t2 = false, i2 = o.STATUS.PENDING, r2 = this.uploader.opts.checkChunkUploadedByResponse;
    if (this.opts.prioritizeFirstAndLastChunk && (s.each(this.files, function(e4) {
      if (!e4.paused && (!r2 || e4._firstResponse || !e4.isUploading()))
        return e4.chunks.length && e4.chunks[0].status() === i2 ? (e4.chunks[0].send(), t2 = true, false) : e4.chunks.length > 1 && e4.chunks[e4.chunks.length - 1].status() === i2 ? (e4.chunks[e4.chunks.length - 1].send(), t2 = true, false) : void 0;
    }), t2))
      return t2;
    if (s.each(this.files, function(e4) {
      if (!e4.paused) {
        if (r2 && !e4._firstResponse && e4.isUploading())
          return;
        s.each(e4.chunks, function(e5) {
          if (e5.status() === i2)
            return e5.send(), t2 = true, false;
        });
      }
      if (t2)
        return false;
    }), t2)
      return true;
    var n2 = false;
    return s.each(this.files, function(e4) {
      if (!e4.isComplete())
        return n2 = true, false;
    }), n2 || e3 || !this.files.length || this._triggerAsync("complete"), n2;
  }, upload: function(e3) {
    var t2 = this._shouldUploadNext();
    if (false !== t2) {
      !e3 && this._trigger("uploadStart");
      for (var i2 = false, s2 = 1; s2 <= this.opts.simultaneousUploads - t2 && ((i2 = this.uploadNextChunk(!e3) || i2) || !e3); s2++)
        ;
      i2 || e3 || this._triggerAsync("complete");
    }
  }, _shouldUploadNext: function() {
    var e3 = 0, t2 = true, i2 = this.opts.simultaneousUploads, r2 = o.STATUS.UPLOADING;
    return s.each(this.files, function(n2) {
      return s.each(n2.chunks, function(s2) {
        if (s2.status() === r2 && ++e3 >= i2)
          return t2 = false, false;
      }), t2;
    }), t2 && e3;
  }, assignBrowse: function(e3, t2, i2, r2) {
    void 0 === e3.length && (e3 = [e3]), s.each(e3, function(e4) {
      var n2;
      "INPUT" === e4.tagName && "file" === e4.type ? n2 = e4 : ((n2 = document.createElement("input")).setAttribute("type", "file"), s.extend(n2.style, { visibility: "hidden", position: "absolute", width: "1px", height: "1px" }), e4.appendChild(n2), e4.addEventListener("click", function(t3) {
        "label" !== e4.tagName.toLowerCase() && n2.click();
      }, false)), this.opts.singleFile || i2 || n2.setAttribute("multiple", "multiple"), t2 && n2.setAttribute("webkitdirectory", "webkitdirectory"), r2 && s.each(r2, function(e5, t3) {
        n2.setAttribute(t3, e5);
      });
      var o2 = this;
      n2.addEventListener("change", function(e5) {
        o2._trigger(e5.type, e5), e5.target.value && (o2.addFiles(e5.target.files, e5), e5.target.value = "");
      }, false);
    }, this);
  }, onDrop: function(e3) {
    this._trigger(e3.type, e3), this.opts.onDropStopPropagation && e3.stopPropagation(), e3.preventDefault(), this._parseDataTransfer(e3.dataTransfer, e3);
  }, _parseDataTransfer: function(e3, t2) {
    e3.items && e3.items[0] && e3.items[0].webkitGetAsEntry ? this.webkitReadDataTransfer(e3, t2) : this.addFiles(e3.files, t2);
  }, webkitReadDataTransfer: function(e3, t2) {
    var i2 = this, r2 = e3.items.length, n2 = [];
    function o2(e4) {
      e4.readEntries(function(t3) {
        t3.length ? (r2 += t3.length, s.each(t3, function(e5) {
          if (e5.isFile) {
            var t4 = e5.fullPath;
            e5.file(function(e6) {
              a2(e6, t4);
            }, l2);
          } else
            e5.isDirectory && o2(e5.createReader());
        }), o2(e4)) : u2();
      }, l2);
    }
    function a2(e4, t3) {
      e4.relativePath = t3.substring(1), n2.push(e4), u2();
    }
    function l2(e4) {
      throw e4;
    }
    function u2() {
      0 == --r2 && i2.addFiles(n2, t2);
    }
    s.each(e3.items, function(e4) {
      var t3 = e4.webkitGetAsEntry();
      t3 ? t3.isFile ? a2(e4.getAsFile(), t3.fullPath) : o2(t3.createReader()) : u2();
    });
  }, _assignHelper: function(e3, t2, i2) {
    void 0 === e3.length && (e3 = [e3]);
    var r2 = i2 ? "removeEventListener" : "addEventListener";
    s.each(e3, function(e4) {
      s.each(t2, function(t3, i3) {
        e4[r2](i3, t3, false);
      }, this);
    }, this);
  }, _preventEvent: function(e3) {
    s.preventEvent(e3), this._trigger(e3.type, e3);
  }, assignDrop: function(e3) {
    this._onDrop = s.bind(this.onDrop, this), this._assignHelper(e3, { dragover: this.preventEvent, dragenter: this.preventEvent, dragleave: this.preventEvent, drop: this._onDrop });
  }, unAssignDrop: function(e3) {
    this._assignHelper(e3, { dragover: this.preventEvent, dragenter: this.preventEvent, dragleave: this.preventEvent, drop: this._onDrop }, true), this._onDrop = null;
  } }), t.exports = d;
}, { "./chunk": 1, "./event": 2, "./file": 4, "./utils": 5 }], 4: [function(e2, t, i) {
  var s = e2("./utils"), r = e2("./chunk");
  function n(e3, t2, i2) {
    s.defineNonEnumerable(this, "uploader", e3), this.isRoot = this.isFolder = e3 === this, s.defineNonEnumerable(this, "parent", i2 || null), s.defineNonEnumerable(this, "files", []), s.defineNonEnumerable(this, "fileList", []), s.defineNonEnumerable(this, "chunks", []), s.defineNonEnumerable(this, "_errorFiles", []), s.defineNonEnumerable(this, "file", null), this.id = s.uid(), this.isRoot || !t2 ? this.file = null : s.isString(t2) ? (this.isFolder = true, this.file = null, this.path = t2, this.parent.path && (t2 = t2.substr(this.parent.path.length)), this.name = "/" === t2.charAt(t2.length - 1) ? t2.substr(0, t2.length - 1) : t2) : (this.file = t2, this.fileType = this.file.type, this.name = t2.fileName || t2.name, this.size = t2.size, this.relativePath = t2.relativePath || t2.webkitRelativePath || this.name, this._parseFile()), this.paused = e3.opts.initialPaused, this.error = false, this.allError = false, this.aborted = false, this.completed = false, this.averageSpeed = 0, this.currentSpeed = 0, this._lastProgressCallback = Date.now(), this._prevUploadedSize = 0, this._prevProgress = 0, this.bootstrap();
  }
  function o(e3) {
    var t2 = [], i2 = e3.split("/"), s2 = i2.length, r2 = 1;
    if (i2.splice(s2 - 1, 1), s2--, i2.length)
      for (; r2 <= s2; )
        t2.push(i2.slice(0, r2++).join("/") + "/");
    return t2;
  }
  s.extend(n.prototype, { _parseFile: function() {
    var e3 = o(this.relativePath);
    if (e3.length) {
      var t2 = this.uploader.filePaths;
      s.each(e3, function(i2, s2) {
        var r2 = t2[i2];
        r2 || (r2 = new n(this.uploader, i2, this.parent), t2[i2] = r2, this._updateParentFileList(r2)), this.parent = r2, r2.files.push(this), e3[s2 + 1] || r2.fileList.push(this);
      }, this);
    } else
      this._updateParentFileList();
  }, _updateParentFileList: function(e3) {
    e3 || (e3 = this);
    var t2 = this.parent;
    t2 && t2.fileList.push(e3);
  }, _eachAccess: function(e3, t2) {
    this.isFolder ? s.each(this.files, function(t3, i2) {
      return e3.call(this, t3, i2);
    }, this) : t2.call(this, this);
  }, bootstrap: function() {
    if (!this.isFolder) {
      var e3 = this.uploader.opts;
      s.isFunction(e3.initFileFn) && e3.initFileFn.call(this, this), this.abort(true), this._resetError(), this._prevProgress = 0;
      for (var t2 = e3.forceChunkSize ? Math.ceil : Math.floor, i2 = Math.max(t2(this.size / e3.chunkSize), 1), n2 = 0; n2 < i2; n2++)
        this.chunks.push(new r(this.uploader, this, n2));
    }
  }, _measureSpeed: function() {
    var e3 = this.uploader.opts.speedSmoothingFactor, t2 = Date.now() - this._lastProgressCallback;
    if (t2) {
      var i2 = this.sizeUploaded();
      this.currentSpeed = Math.max((i2 - this._prevUploadedSize) / t2 * 1e3, 0), this.averageSpeed = e3 * this.currentSpeed + (1 - e3) * this.averageSpeed, this._prevUploadedSize = i2, this.parent && this.parent._checkProgress() && this.parent._measureSpeed();
    }
  }, _checkProgress: function(e3) {
    return Date.now() - this._lastProgressCallback >= this.uploader.opts.progressCallbacksInterval;
  }, _chunkEvent: function(e3, t2, i2) {
    var s2 = this.uploader, n2 = r.STATUS, o2 = this, a = this.getRoot(), l = function() {
      o2._measureSpeed(), s2._trigger("fileProgress", a, o2, e3), o2._lastProgressCallback = Date.now();
    };
    switch (t2) {
      case n2.PROGRESS:
        this._checkProgress() && l();
        break;
      case n2.ERROR:
        this._error(), this.abort(true), s2._trigger("fileError", a, this, i2, e3);
        break;
      case n2.SUCCESS:
        if (this._updateUploadedChunks(i2, e3), this.error)
          return;
        clearTimeout(this._progeressId), this._progeressId = 0;
        var u = Date.now() - this._lastProgressCallback;
        u < s2.opts.progressCallbacksInterval && (this._progeressId = setTimeout(l, s2.opts.progressCallbacksInterval - u)), this.isComplete() ? (clearTimeout(this._progeressId), l(), this.currentSpeed = 0, this.averageSpeed = 0, s2._trigger("fileSuccess", a, this, i2, e3), a.isComplete() && s2._trigger("fileComplete", a, this)) : this._progeressId || l();
        break;
      case n2.RETRY:
        s2._trigger("fileRetry", a, this, e3);
    }
  }, _updateUploadedChunks: function(e3, t2) {
    var i2 = this.uploader.opts.checkChunkUploadedByResponse;
    if (i2) {
      var r2 = t2.xhr;
      s.each(this.chunks, function(s2) {
        if (!s2.tested) {
          var n2 = i2.call(this, s2, e3);
          s2 !== t2 || n2 || (s2.xhr = null), n2 && (s2.xhr = r2), s2.tested = true;
        }
      }, this), this._firstResponse ? this.uploader.uploadNextChunk() : (this._firstResponse = true, this.uploader.upload(true));
    } else
      this.uploader.uploadNextChunk();
  }, _error: function() {
    this.error = this.allError = true;
    for (var e3 = this.parent; e3 && e3 !== this.uploader; )
      e3._errorFiles.push(this), e3.error = true, e3._errorFiles.length === e3.files.length && (e3.allError = true), e3 = e3.parent;
  }, _resetError: function() {
    this.error = this.allError = false;
    for (var e3 = this.parent, t2 = -1; e3 && e3 !== this.uploader; )
      t2 = e3._errorFiles.indexOf(this), e3._errorFiles.splice(t2, 1), e3.allError = false, e3._errorFiles.length || (e3.error = false), e3 = e3.parent;
  }, isComplete: function() {
    if (!this.completed) {
      var e3 = false;
      this._eachAccess(function(t2) {
        if (!t2.isComplete())
          return e3 = true, false;
      }, function() {
        if (this.error)
          e3 = true;
        else {
          var t2 = r.STATUS;
          s.each(this.chunks, function(i2) {
            var s2 = i2.status();
            if (s2 === t2.ERROR || s2 === t2.PENDING || s2 === t2.UPLOADING || s2 === t2.READING || 1 === i2.preprocessState || 1 === i2.readState)
              return e3 = true, false;
          });
        }
      }), this.completed = !e3;
    }
    return this.completed;
  }, isUploading: function() {
    var e3 = false;
    return this._eachAccess(function(t2) {
      if (t2.isUploading())
        return e3 = true, false;
    }, function() {
      var t2 = r.STATUS.UPLOADING;
      s.each(this.chunks, function(i2) {
        if (i2.status() === t2)
          return e3 = true, false;
      });
    }), e3;
  }, resume: function() {
    this._eachAccess(function(e3) {
      e3.resume();
    }, function() {
      this.paused = false, this.aborted = false, this.uploader.upload();
    }), this.paused = false, this.aborted = false;
  }, pause: function() {
    this._eachAccess(function(e3) {
      e3.pause();
    }, function() {
      this.paused = true, this.abort();
    }), this.paused = true;
  }, cancel: function() {
    this.uploader.removeFile(this);
  }, retry: function(e3) {
    var t2 = function(e4) {
      e4.error && e4.bootstrap();
    };
    e3 ? e3.bootstrap() : this._eachAccess(t2, function() {
      this.bootstrap();
    }), this.uploader.upload();
  }, abort: function(e3) {
    if (!this.aborted) {
      this.currentSpeed = 0, this.averageSpeed = 0, this.aborted = !e3;
      var t2 = this.chunks;
      e3 && (this.chunks = []);
      var i2 = r.STATUS.UPLOADING;
      s.each(t2, function(e4) {
        e4.status() === i2 && (e4.abort(), this.uploader.uploadNextChunk());
      }, this);
    }
  }, progress: function() {
    var e3 = 0, t2 = 0, i2 = 0;
    return this._eachAccess(function(s2, r2) {
      e3 += s2.progress() * s2.size, t2 += s2.size, r2 === this.files.length - 1 && (i2 = t2 > 0 ? e3 / t2 : this.isComplete() ? 1 : 0);
    }, function() {
      if (this.error)
        i2 = 1;
      else {
        if (1 === this.chunks.length)
          return this._prevProgress = Math.max(this._prevProgress, this.chunks[0].progress()), void (i2 = this._prevProgress);
        var e4 = 0;
        s.each(this.chunks, function(t4) {
          e4 += t4.progress() * (t4.endByte - t4.startByte);
        });
        var t3 = e4 / this.size;
        this._prevProgress = Math.max(this._prevProgress, t3 > 0.9999 ? 1 : t3), i2 = this._prevProgress;
      }
    }), i2;
  }, getSize: function() {
    var e3 = 0;
    return this._eachAccess(function(t2) {
      e3 += t2.size;
    }, function() {
      e3 += this.size;
    }), e3;
  }, getFormatSize: function() {
    var e3 = this.getSize();
    return s.formatSize(e3);
  }, getRoot: function() {
    if (this.isRoot)
      return this;
    for (var e3 = this.parent; e3; ) {
      if (e3.parent === this.uploader)
        return e3;
      e3 = e3.parent;
    }
    return this;
  }, sizeUploaded: function() {
    var e3 = 0;
    return this._eachAccess(function(t2) {
      e3 += t2.sizeUploaded();
    }, function() {
      s.each(this.chunks, function(t2) {
        e3 += t2.sizeUploaded();
      });
    }), e3;
  }, timeRemaining: function() {
    var e3 = 0, t2 = 0, i2 = 0;
    return this._eachAccess(function(r2, n2) {
      r2.paused || r2.error || (t2 += r2.size - r2.sizeUploaded(), i2 += r2.averageSpeed), n2 === this.files.length - 1 && (e3 = s2(t2, i2));
    }, function() {
      if (this.paused || this.error)
        e3 = 0;
      else {
        var t3 = this.size - this.sizeUploaded();
        e3 = s2(t3, this.averageSpeed);
      }
    }), e3;
    function s2(e4, t3) {
      return e4 && !t3 ? Number.POSITIVE_INFINITY : e4 || t3 ? Math.floor(e4 / t3) : 0;
    }
  }, removeFile: function(e3) {
    if (e3.isFolder)
      for (; e3.files.length; ) {
        var t2 = e3.files[e3.files.length - 1];
        this._removeFile(t2);
      }
    this._removeFile(e3);
  }, _delFilePath: function(e3) {
    e3.path && this.filePaths && delete this.filePaths[e3.path], s.each(e3.fileList, function(e4) {
      this._delFilePath(e4);
    }, this);
  }, _removeFile: function(e3) {
    if (!e3.isFolder) {
      s.each(this.files, function(t3, i3) {
        if (t3 === e3)
          return this.files.splice(i3, 1), false;
      }, this), e3.abort();
      for (var t2, i2 = e3.parent; i2 && i2 !== this; )
        t2 = i2.parent, i2._removeFile(e3), i2 = t2;
    }
    e3.parent === this && s.each(this.fileList, function(t3, i3) {
      if (t3 === e3)
        return this.fileList.splice(i3, 1), false;
    }, this), this.isRoot || !this.isFolder || this.files.length || (this.parent._removeFile(this), this.uploader._delFilePath(this)), e3.parent = null;
  }, getType: function() {
    return this.isFolder ? "folder" : this.file.type && this.file.type.split("/")[1];
  }, getExtension: function() {
    return this.isFolder ? "" : this.name.substr(2 + (~-this.name.lastIndexOf(".") >>> 0)).toLowerCase();
  } }), t.exports = n;
}, { "./chunk": 1, "./utils": 5 }], 5: [function(e2, t, i) {
  var s = Object.prototype, r = Array.prototype, n = s.toString, o = function(e3) {
    return "[object Function]" === n.call(e3);
  }, a = Array.isArray || function(e3) {
    return "[object Array]" === n.call(e3);
  }, l = function(e3) {
    return "[object Object]" === n.call(e3) && Object.getPrototypeOf(e3) === s;
  }, u = 0, p = { uid: function() {
    return ++u;
  }, noop: function() {
  }, bind: function(e3, t2) {
    return function() {
      return e3.apply(t2, arguments);
    };
  }, preventEvent: function(e3) {
    e3.preventDefault();
  }, stop: function(e3) {
    e3.preventDefault(), e3.stopPropagation();
  }, nextTick: function(e3, t2) {
    setTimeout(p.bind(e3, t2), 0);
  }, toArray: function(e3, t2, i2) {
    return void 0 === t2 && (t2 = 0), void 0 === i2 && (i2 = e3.length), r.slice.call(e3, t2, i2);
  }, isPlainObject: l, isFunction: o, isArray: a, isObject: function(e3) {
    return Object(e3) === e3;
  }, isString: function(e3) {
    return "string" == typeof e3;
  }, isUndefined: function(e3) {
    return void 0 === e3;
  }, isDefined: function(e3) {
    return void 0 !== e3;
  }, each: function(e3, t2, i2) {
    if (p.isDefined(e3.length))
      for (var s2 = 0, r2 = e3.length; s2 < r2 && false !== t2.call(i2, e3[s2], s2, e3); s2++)
        ;
    else
      for (var n2 in e3)
        if (false === t2.call(i2, e3[n2], n2, e3))
          break;
  }, evalOpts: function(e3, t2) {
    return p.isFunction(e3) && (t2 = p.toArray(arguments), e3 = e3.apply(null, t2.slice(1))), e3;
  }, extend: function() {
    var e3, t2, i2, s2, r2, n2, u2 = arguments[0] || {}, h = 1, d = arguments.length, f = false;
    for ("boolean" == typeof u2 && (f = u2, u2 = arguments[1] || {}, h++), "object" == typeof u2 || o(u2) || (u2 = {}), h === d && (u2 = this, h--); h < d; h++)
      if (null != (e3 = arguments[h]))
        for (t2 in e3)
          i2 = u2[t2], u2 !== (s2 = e3[t2]) && (f && s2 && (l(s2) || (r2 = a(s2))) ? (r2 ? (r2 = false, n2 = i2 && a(i2) ? i2 : []) : n2 = i2 && l(i2) ? i2 : {}, u2[t2] = p.extend(f, n2, s2)) : void 0 !== s2 && (u2[t2] = s2));
    return u2;
  }, formatSize: function(e3) {
    return e3 < 1024 ? e3.toFixed(0) + " bytes" : e3 < 1048576 ? (e3 / 1024).toFixed(0) + " KB" : e3 < 1073741824 ? (e3 / 1024 / 1024).toFixed(1) + " MB" : (e3 / 1024 / 1024 / 1024).toFixed(1) + " GB";
  }, defineNonEnumerable: function(e3, t2, i2) {
    Object.defineProperty(e3, t2, { enumerable: false, configurable: true, writable: true, value: i2 });
  } };
  t.exports = p;
}, {}] }, {}, [3])(3);
function x(e2) {
  return e2.replace(/[A-Z]/g, (e3) => `-${e3.toLowerCase()}`);
}
var C = { name: "uploader-btn", props: { directory: { type: Boolean, default: false }, single: { type: Boolean, default: false }, attrs: { type: Object, default: () => ({}) } }, setup(r) {
  const n = ref(null), o = inject("uploader").proxy.uploader, a = o.support;
  return onMounted(() => {
    nextTick(() => {
      o.assignBrowse(n.value, r.directory, r.single, r.attrs);
    });
  }), { btn: n, support: a };
} };
var A = { class: "uploader-btn", ref: "btn" };
C.render = function(e2, t, i, s, u, p) {
  return withDirectives((openBlock(), createBlock("label", A, [renderSlot(e2.$slots, "default")], 512)), [[vShow, s.support]]);
};
var P = { name: "uploader-drop", setup() {
  const r = inject("uploader").proxy.uploader;
  let n = ref(null), o = ref("");
  const a = r.support, l = () => {
    o = "uploader-dragover";
  }, p = () => {
    o = "";
  }, h = () => {
    o = "uploader-droped";
  };
  return onMounted(() => {
    nextTick(() => {
      const e2 = n.value;
      r.assignDrop(e2), r.on("dragenter", l), r.on("dragleave", p), r.on("drop", h);
    });
  }), onBeforeUnmount(() => {
    const e2 = n.value;
    r.off("dragenter", l), r.off("dragleave", p), r.off("drop", h), r.unAssignDrop(e2);
  }), { drop: n, dropClass: o, support: a, onDragEnter: l, onDragLeave: p, onDrop: h };
} };
P.render = function(e2, t, i, s, u, p) {
  return withDirectives((openBlock(), createBlock("div", { class: ["uploader-drop", s.dropClass], ref: "drop" }, [renderSlot(e2.$slots, "default")], 2)), [[vShow, s.support]]);
};
var U = { name: "uploader-unsupport", setup: () => ({ support: inject("uploader").proxy.uploader.support }) };
var w = { class: "uploader-unsupport" };
var D = createVNode("p", null, [createTextVNode(" Your browser, unfortunately, is not supported by Uploader.js. The library requires support for "), createVNode("a", { href: "http://www.w3.org/TR/FileAPI/" }, "the HTML5 File API"), createTextVNode(" along with "), createVNode("a", { href: "http://www.w3.org/TR/FileAPI/#normalization-of-params" }, "file slicing"), createTextVNode(". ")], -1);
U.render = function(e2, t, i, s, u, p) {
  return withDirectives((openBlock(), createBlock("div", w, [renderSlot(e2.$slots, "default", {}, () => [D])], 512)), [[vShow, !s.support]]);
};
var z = ["fileProgress", "fileSuccess", "fileComplete", "fileError"];
var T = { name: "uploader-file", props: { file: { type: Object, default: () => ({}) }, list: { type: Boolean, default: false } }, setup(t) {
  const s = getCurrentInstance();
  let r = {}, n = 0;
  const o = ref(null), a = ref(false), l = ref(false), u = ref(0), p = ref(0), h = ref(false), g = ref(false), S = ref(0), y = ref(""), _ = ref(0), b = ref(0), k = ref(0), R2 = ref(""), F2 = ref(""), x2 = ref(""), C2 = computed(() => {
    let e2 = t.file.isFolder ? "folder" : "unknown";
    const i = t.file.uploader.opts.categoryMap || { image: ["gif", "jpg", "jpeg", "png", "bmp", "webp"], video: ["mp4", "m3u8", "rmvb", "avi", "swf", "3gp", "mkv", "flv"], audio: ["mp3", "wav", "wma", "ogg", "aac", "flac"], document: ["doc", "txt", "docx", "pages", "epub", "pdf", "numbers", "csv", "xls", "xlsx", "keynote", "ppt", "pptx"] };
    return Object.keys(i).forEach((t2) => {
      i[t2].indexOf(F2.value) > -1 && (e2 = t2);
    }), e2;
  }), A2 = computed(() => {
    b.value = Math.floor(100 * b.value);
    const e2 = `translateX(${Math.floor(b.value - 100)}%)`;
    return { progress: `${b.value}%`, webkitTransform: e2, mozTransform: e2, msTransform: e2, transform: e2 };
  }), P2 = computed(() => `${E.utils.formatSize(u.value)} / s`), U2 = computed(() => {
    let e2 = l;
    return h.value ? "success" : e2.value ? "error" : g.value ? "uploading" : a.value ? "paused" : "waiting";
  }), w2 = computed(() => {
    const e2 = t.file.uploader.fileStatusText;
    let i = U2.value;
    return i = "function" == typeof e2 ? e2(U2.value, o.value) : e2[U2.value], i || U2;
  }), D2 = computed(() => {
    const e2 = t.file;
    if (k.value === Number.POSITIVE_INFINITY || 0 === k.value)
      return "";
    let i = function(e3) {
      const t2 = Math.floor(e3 / 31536e3);
      if (t2)
        return t2 + " year" + o2(t2);
      const i2 = Math.floor((e3 %= 31536e3) / 86400);
      if (i2)
        return i2 + " day" + o2(i2);
      const s3 = Math.floor((e3 %= 86400) / 3600);
      if (s3)
        return s3 + " hour" + o2(s3);
      const r2 = Math.floor((e3 %= 3600) / 60);
      if (r2)
        return r2 + " minute" + o2(r2);
      const n2 = e3 % 60;
      return n2 + " second" + o2(n2);
      function o2(e4) {
        return e4 > 1 ? "s" : "";
      }
    }(k.value);
    const s2 = e2.uploader.opts.parseTimeRemaining;
    return s2 && (i = s2(k.value, i)), i;
  }), T2 = () => {
    a.value = t.file.paused, l.value = t.file.error, g.value = t.file.isUploading();
  }, N2 = (e2) => {
    let t2 = e2;
    try {
      t2 = JSON.parse(e2);
    } catch (i) {
    }
    o.value = t2;
  }, I2 = (e2, i) => {
    const r2 = i[0], n2 = i[1], o2 = t.list ? r2 : n2;
    if (toRaw(t.file) === toRaw(o2)) {
      if (t.list && "fileSuccess" === e2)
        return void N2(i[2]);
      s.setupState[e2](...i);
    }
  }, L2 = () => {
    b.value = t.file.progress(), u.value = t.file.averageSpeed, p.value = t.file.currentSpeed, k.value = t.file.timeRemaining(), _.value = t.file.sizeUploaded(), T2();
  }, O2 = (e2, t2, i) => {
    e2 && N2(i), L2(), l.value = false, h.value = true, g.value = false;
  };
  return watch(U2, (e2, t2) => {
    t2 && "uploading" === e2 && "uploading" !== t2 ? n = setTimeout(() => {
      x2.value = "uploader-file-progressing";
    }, 200) : (clearTimeout(n), x2.value = "");
  }), onMounted(() => {
    a.value = t.file.paused, l.value = t.file.error, u.value = t.file.averageSpeed, p.value = t.file.currentSpeed, h.value = t.file.isComplete(), g.value = t.file.isUploading(), S.value = t.file.getSize(), y.value = t.file.getFormatSize(), _.value = t.file.sizeUploaded(), b.value = t.file.progress(), k.value = t.file.timeRemaining(), R2.value = t.file.getType(), F2.value = t.file.getExtension();
    z.forEach((e2) => {
      t.file.uploader.on(e2, ((e3) => (r[e3] = (...t2) => {
        I2(e3, t2);
      }, r[e3]))(e2));
    });
  }), onUnmounted(() => {
    z.forEach((e2) => {
      t.file.uploader.off(e2, r[e2]);
    }), r = null;
  }), { response: o, paused: a, error: l, averageSpeed: u, currentSpeed: p, isComplete: h, isUploading: g, size: S, formatedSize: y, uploadedSize: _, progress: b, timeRemaining: k, type: R2, extension: F2, progressingClass: x2, fileCategory: C2, progressStyle: A2, formatedAverageSpeed: P2, status: U2, statusText: w2, formatedTimeRemaining: D2, actionCheck: T2, pause: () => {
    t.file.pause(), T2(), L2();
  }, resume: () => {
    t.file.resume(), T2();
  }, remove: () => {
    t.file.cancel();
  }, retry: () => {
    t.file.retry(), T2();
  }, processResponse: N2, fileEventsHandler: I2, fileProgress: L2, fileSuccess: O2, fileComplete: () => {
    O2();
  }, fileError: (e2, t2, i) => {
    L2(), N2(i), l.value = true, h.value = false, g.value = false;
  } };
} };
var N = { class: "uploader-file-info" };
var I = { class: "uploader-file-name" };
var L = { class: "uploader-file-size" };
var O = createVNode("div", { class: "uploader-file-meta" }, null, -1);
var B = { class: "uploader-file-status" };
var G = { class: "uploader-file-actions" };
T.render = function(e2, t, i, s, u, d) {
  return openBlock(), createBlock("div", { class: "uploader-file", status: s.status }, [renderSlot(e2.$slots, "default", { file: i.file, list: i.list, status: s.status, paused: s.paused, error: s.error, response: s.response, averageSpeed: s.averageSpeed, formatedAverageSpeed: s.formatedAverageSpeed, currentSpeed: s.currentSpeed, isComplete: s.isComplete, isUploading: s.isUploading, size: s.size, formatedSize: s.formatedSize, uploadedSize: s.uploadedSize, progress: s.progress, progressStyle: s.progressStyle, progressingClass: s.progressingClass, timeRemaining: s.timeRemaining, formatedTimeRemaining: s.formatedTimeRemaining, type: s.type, extension: s.extension, fileCategory: s.fileCategory }, () => [createVNode("div", { class: ["uploader-file-progress", s.progressingClass], style: s.progressStyle }, null, 6), createVNode("div", N, [createVNode("div", I, [createVNode("i", { class: "uploader-file-icon", icon: s.fileCategory }, null, 8, ["icon"]), createTextVNode(toDisplayString(i.file.name), 1)]), createVNode("div", L, toDisplayString(s.formatedSize), 1), O, createVNode("div", B, [withDirectives(createVNode("span", null, toDisplayString(s.statusText), 513), [[vShow, "uploading" !== s.status]]), withDirectives(createVNode("span", null, [createVNode("span", null, toDisplayString(s.progressStyle.progress) + " ", 1), createVNode("em", null, toDisplayString(s.formatedAverageSpeed) + " ", 1), createVNode("i", null, toDisplayString(s.formatedTimeRemaining), 1)], 512), [[vShow, "uploading" === s.status]])]), createVNode("div", G, [createVNode("span", { class: "uploader-file-pause", onClick: t[1] || (t[1] = (...e3) => s.pause && s.pause(...e3)) }), createVNode("span", { class: "uploader-file-resume", onClick: t[2] || (t[2] = (...e3) => s.resume && s.resume(...e3)) }, "️"), createVNode("span", { class: "uploader-file-retry", onClick: t[3] || (t[3] = (...e3) => s.retry && s.retry(...e3)) }), createVNode("span", { class: "uploader-file-remove", onClick: t[4] || (t[4] = (...e3) => s.remove && s.remove(...e3)) })])])])], 8, ["status"]);
};
var M = { name: "uploader-list", components: { UploaderFile: T }, setup() {
  const e2 = inject("uploader").proxy;
  return { fileList: computed(() => e2.fileList) };
} };
var j = { class: "uploader-list" };
M.render = function(e2, t, i, s, r, l) {
  const u = resolveComponent("uploader-file");
  return openBlock(), createBlock("div", j, [renderSlot(e2.$slots, "default", { fileList: s.fileList }, () => [createVNode("ul", null, [(openBlock(true), createBlock(Fragment, null, renderList(s.fileList, (e3) => (openBlock(), createBlock("li", { key: e3.id }, [createVNode(u, { file: e3, list: true }, null, 8, ["file"])]))), 128))])])]);
};
var q = { name: "uploader-files", components: { UploaderFile: T }, setup() {
  const e2 = inject("uploader").proxy;
  return { files: computed(() => e2.files) };
} };
var $ = { class: "uploader-files" };
q.render = function(e2, t, i, s, r, l) {
  const u = resolveComponent("uploader-file");
  return openBlock(), createBlock("div", $, [renderSlot(e2.$slots, "default", { files: s.files }, () => [createVNode("ul", null, [(openBlock(true), createBlock(Fragment, null, renderList(s.files, (e3) => (openBlock(), createBlock("li", { key: e3.id }, [createVNode(u, { file: e3 }, null, 8, ["file"])]))), 128))])])]);
};
var H = { name: "uploader", props: { options: { type: Object, default: () => ({}) }, autoStart: { type: Boolean, default: true }, fileStatusText: { type: [Object, Function], default: () => ({ success: "success", error: "error", uploading: "uploading", paused: "paused", waiting: "waiting" }) }, onFileAdded: Function, onFilesAdded: Function }, emits: ["change", "dragover", "dragenter", "dragleave", "file-success", "file-complete", "file-progress", "file-added", "files-added", "files-submitted", "file-removed", "file-retry", "file-error", "upload-start", "complete"], setup(t, { emit: i }) {
  const s = ref(false), r = ref([]), n = ref([]), o = getCurrentInstance();
  let a = new E(t.options);
  const l = (e2) => {
    const s2 = e2;
    if (t.onFileAdded) {
      if (false === t.onFileAdded(s2) || s2.ignored)
        return false;
    } else if (i(x("fileAdded"), s2), s2.ignored)
      return false;
  }, u = (e2, s2) => {
    if (t.onFilesAdded) {
      if (false === t.onFilesAdded(e2, s2) || e2.ignored || s2.ignored)
        return false;
    } else if (i(x("filesAdded"), e2, s2), e2.ignored || s2.ignored)
      return false;
  }, p = () => {
    r.value = [...a.files], n.value = [...a.fileList];
  }, h = () => {
    r.value = [...a.files], n.value = [...a.fileList], t.autoStart && a.upload();
  }, f = (...e2) => {
    const t2 = e2[0], s2 = { fileAdded: true, filesAdded: true, uploadStart: "uploadStart" }[t2];
    if (s2) {
      if (true === s2)
        return;
      o.setupState[s2](...e2.slice(1));
    }
    e2[0] = x(t2), i(...e2);
  };
  return t.options.initialPaused = !t.autoStart, a.fileStatusText = t.fileStatusText, a.on("catchAll", f), a.on("fileAdded", l), a.on("filesAdded", u), a.on("fileRemoved", p), a.on("filesSubmitted", h), onUnmounted(() => {
    a.off("catchAll", f), a.off("fileAdded", l), a.off("filesAdded", u), a.off("fileRemoved", p), a.off("filesSubmitted", h), a = null;
  }), provide("uploader", o), { uploader: a, started: s, files: r, fileList: n, uploadStart: () => {
    s.value = true;
  }, fileAdded: l, filesAdded: u, fileRemoved: p, filesSubmitted: h, allEvent: f };
}, components: { UploaderBtn: C, UploaderDrop: P, UploaderUnsupport: U, UploaderList: M, UploaderFiles: q, UploaderFile: T } };
var X = { class: "uploader" };
var Y = createVNode("p", null, "Drop files here to upload or", -1);
var V = createTextVNode("select files");
var Z = createTextVNode("select folder");
H.render = function(e2, t, i, s, r, l) {
  const u = resolveComponent("uploader-unsupport"), h = resolveComponent("uploader-btn"), d = resolveComponent("uploader-drop"), f = resolveComponent("uploader-list");
  return openBlock(), createBlock("div", X, [renderSlot(e2.$slots, "default", { files: s.files, fileList: s.fileList, started: s.started }, () => [createVNode(u), createVNode(d, null, { default: withCtx(() => [Y, createVNode(h, null, { default: withCtx(() => [V]), _: 1 }), createVNode(h, { directory: true }, { default: withCtx(() => [Z]), _: 1 })]), _: 1 }), createVNode(f)])]);
};
var J = { version: "1.0.2", install: function(e2, t) {
  e2.component(H.name, H), e2.component(C.name, C), e2.component(P.name, P), e2.component(U.name, U), e2.component(M.name, M), e2.component(q.name, q), e2.component(T.name, T);
}, Uploader: H, UploaderBtn: C, UploaderDrop: P, UploaderUnsupport: U, UploaderList: M, UploaderFiles: q, UploaderFile: T };
var vue_simple_uploader_es_default = J;
export {
  vue_simple_uploader_es_default as default
};
/*! Bundled license information:

vue-simple-uploader/dist/vue-simple-uploader.es.js:
  (*!
   * Uploader - Uploader library implements html5 file upload and provides multiple simultaneous, stable, fault tolerant and resumable uploads
   * @version v0.6.0
   * @author dolymood <dolymood@gmail.com>
   * @link https://github.com/simple-uploader/Uploader
   * @license MIT
   *)
*/
//# sourceMappingURL=vue-simple-uploader.js.map
